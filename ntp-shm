#!/usr/bin/perl

# part of this code is from: https://github.com/doug1/psip-time/blob/master/psip-time.pl
# This module is free software. You can redistribute it and/or
# modify it under the terms of the Artistic License 2.0.
#
# This program is distributed in the hope that it will be useful,
# but without any warranty; without even the implied warranty of
# merchantability or fitness for a particular purpose.
#
# example /etc/ntp.conf:
# server 127.127.28.0 minpoll 4 maxpoll 4
# fudge 127.127.28.0 time1 0.000 refid GPS stratum 0
#
# to run this program:
# ./ntp-shm </dev/ttyACM0
# Adjust /dev/ttyACM0 to match your device (see dmesg). Needs to run as root (shm permissions)

use strict;
use Time::HiRes qw(gettimeofday tv_interval usleep);
use Time::Local qw(timegm);
use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);
use IO::Handle;
use Inline "C";
use constant {
  NTP_SHMID => 0x4e545030
};

my $st_interval_estimate = 10500000; # frequency of the timer on the microcontroller

my $gps_time;
my $gps_time_timestamp;
my(%gps_info,%counters);
my(@fixtypes) = ("??","no fix","2D fix","3D fix");
my($last_lock) = 0;
my $gps_line;
sub parseline_time {
  my($now,$line,$interval) = @_;

  # G 3,6,8,27,3,38,32,2,6,13,1,3764701747
  if($line =~ /^G (\d+),(\d+),(\d+),(\d+),(\d+),(\d+),(\d+),(\d+),(\d+),(\d+),(\d+),(\d+)/) {
    my($fixtype,$fixsatcount,$satcount,$avgsnr,$hour,$minute,$second,$day,$month,$year,$valid,$timestamp) = ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12);

    my $new_gps_time = timegm($second,$minute,$hour,$day,$month-1,$year); 
    if($gps_time == $new_gps_time) {
      print "GPS time matches last gps time($gps_time) HZnow=",$timestamp," HZthen=",$gps_time_timestamp,"\n";
      return; # throw away repeat timestamps, TODO: debug this on the microcontroller
    }
    $gps_time = $new_gps_time;
    $gps_time_timestamp = $timestamp;

    chomp($line);
    $gps_line = $line;
    if($gps_time != $now->[0]) {
      print "GPS Time Off: $gps_time != ".$now->[0]."/$gps_line\n";
      $counters{gps_off}++;
    } else {
      $counters{gps_ok}++;
    }
    if($last_lock != $fixtype) {
      print "GPS lock from ".$fixtypes[$last_lock]." to ".$fixtypes[$fixtype]."\n";
      $last_lock = $fixtype;
    }
    if($fixtype == 1) {
      print "sats: $satcount, $avgsnr\n";
    }

    %gps_info = (
        fixsatcount => $fixsatcount,
        satcount => $satcount,
        avgsnr => $avgsnr,
        fixtype => $fixtype,
        valid => $valid
        );
  }
}

my $sample_start = time();
my(@samples);
my $last_time_pps = undef;
sub parseline {
  my($shmid, $line, $now, $interval) = @_;

  if($line =~ /^G [\d,]+/) {
    parseline_time($now,$line,$interval);
    return;
  }

  if($interval > 1.003 or $interval < 0.997) {
    print "skip (local timer=$interval s)\n";
    return; # skip un-even pulses
  }

  my($time_pps, $time_now, $st_interval, $usb_time, $usb_polls);
  if($line =~ /^P (\d+) (\d+) (\d+) (\d+) (\d+)/) {
    ($time_pps, $time_now, $st_interval, $usb_time, $usb_polls) = ($1,$2,$3,$4,$5);
    my $offset = parse_full($now, $shmid, $time_pps, $time_now, $st_interval, $usb_time, $usb_polls);
    if(abs($offset) > 0.0001) {
      chomp($line);
      print "$offset/$line/$st_interval_estimate/$gps_line/$gps_time/".$now->[0]."\n"; 
    }
  } elsif($line =~ /^P (\d+) (\d+)$/) {
    ($time_now, $usb_time) = ($1,$2);
    my $offset = parse_full($now, $shmid, undef, $time_now, undef, $usb_time, undef);
    if(abs($offset) > 0.0001) {
      chomp($line);
      print "$offset/$line/$st_interval_estimate/$last_time_pps/$gps_line/$gps_time/".$now->[0]."\n"; 
    }
  } else {
    print "bad line, $line\n";
    return;
  }
}

sub addcounters {
  my($amount,$name) = @_;

  $counters{$name}++;
  $counters{$name."_sum"} += $amount;
  if(not defined($counters{$name."_min"}) or $amount < $counters{$name."_min"}) {
    $counters{$name."_min"} = $amount;
  }
  if($amount > $counters{$name."_max"}) {
    $counters{$name."_max"} = $amount;
  }
}

sub gps_time_seconds {
  my($gps_time,$gps_time_ms_ago) = @_;

  my $remote_sec = $gps_time;
  if($gps_time_ms_ago > 2700) {
    print "skip (gps time longer than 2s ago=$gps_time_ms_ago ms)\n";
    return undef;
  } elsif($gps_time_ms_ago > 1700) {
    $remote_sec += 2;
    addcounters($gps_time_ms_ago,"over_2s");
  } elsif($gps_time_ms_ago > 700) {
    $remote_sec++;
    addcounters($gps_time_ms_ago,"over_1s");
  } else {
    addcounters($gps_time_ms_ago,"under_1s");
  }
 
  return $remote_sec;
}

sub ntp_message {
  my($remote_sec,$remote_usec,$local_sec,$local_usec) = @_;

  my $nsamples = 0;
  my $valid = 1;
  my $precision = -14;
  my $leap = 0;
  my $count = 0;
  my $mode = 0;

  my $format = "ll". "ql" . "l" . "ql" . "llll" . "l" . "llllllllll";
  my $message = pack( $format, 
		  $mode,      $count,      $remote_sec,  $remote_usec,
		  0,          $local_sec,  $local_usec,  $leap,
		  $precision, $nsamples,   $valid,       0,
		  0,          0,           0,            0,
		  0,          0,           0,            0,
		  0,          0);
  return $message;
}

sub parse_full {
  my($now, $shmid, $time_pps, $time_now, $st_interval, $usb_time, $usb_polls) = @_;

  if(defined($time_pps)) {
    $last_time_pps = $time_pps;
  } else {
    if(defined($last_time_pps)) {
      $time_pps = $last_time_pps;
    } else {
      print "partial time without last time pps\n";
      return;
    }
  }

  if(defined($usb_polls) and ($usb_polls < 499 or $usb_polls > 500)) {
    print "polls: $usb_polls\n";
  }
  if(defined($st_interval)) {
    if($st_interval > 10501000 or $st_interval < 10499999) {
      print "skip (remote timer=$st_interval HZ)\n";
      return; # skip PPS pulses that happen outside of a 500ppm window
    }
    $st_interval_estimate = $st_interval_estimate * 0.8 + $st_interval * 0.2;
  }

  my $gps_time_hz_ago = $time_now - $gps_time_timestamp;
  if($gps_time_hz_ago < 0) { # counter wrap
    $gps_time_hz_ago += 2**32;
  }
  my $gps_time_ms_ago = $gps_time_hz_ago/$st_interval_estimate*1000;
  $gps_time_ms_ago += 700; # serial time is ~700ms off

  my $local_sec = $now->[0];
  my $local_usec = $now->[1];

  my $remote_sec = gps_time_seconds($gps_time,$gps_time_ms_ago);
  if(not defined($remote_sec)) {
    return;
  }
  my $hz_past_0us = $time_now - $time_pps + $usb_time;
  if($time_now < $time_pps) { # counter wrap
    $hz_past_0us += 2**32;
  }
  my $remote_usec = int($hz_past_0us/$st_interval_estimate*1000000);
  if($remote_usec > 1000000) {
    print "partial counter misfire\n";
    return;
  }

  my $message = ntp_message($remote_sec, $remote_usec, $local_sec, $local_usec);

  my $local = $local_sec + ($local_usec / 1000000);
  my $remote = $remote_sec + ($remote_usec / 1000000);
  push(@samples, {
    offset => $remote - $local,
    local => $local,
    remote => $remote,
    message => $message,
    st_interval => $st_interval
  });

  if(defined($st_interval)) { # only on top-of-the-second pps
    check_for_sample_complete($shmid,$local_sec);
  }

  return $remote - $local;
}

my($last_samples);
sub check_for_sample_complete {
  my($shmid,$local_sec) = @_;

  if($sample_start < $local_sec-15) {
    print PPSSAMPLES time()." O ".join(" ", map { $_->{offset} * 1000000 } @samples)."\n";
    print PPSSAMPLES "R ".join(" ", map { $_->{remote} } @samples)."\n";
    my $ntp_info;
    if(@samples > 7) { # we had coverage for more than half the time period
      $ntp_info = send_time_to_ntp($shmid,@samples);
    }
    @samples = sort { $a->{offset} <=> $b->{offset} } @samples;
    printf LOGFILE ("%d %0.6f %0.6f %d %d %d %d %d %d %d %s\n",time(),$samples[0]{offset},$samples[-1]{offset},$#samples,$gps_info{fixsatcount}, $gps_info{satcount}, $gps_info{avgsnr},$gps_info{fixtype},$gps_info{valid},int($st_interval_estimate),$ntp_info);
    if($samples[-1]{offset}-$samples[0]{offset} > 0.001 or $#samples != $last_samples) {
      printf("min = %0.6f max = %0.6f size=%0.6f count=%d hz=%d\n",$samples[0]{offset},$samples[-1]{offset},$samples[-1]{offset}-$samples[0]{offset},$#samples,$st_interval_estimate);
      $last_samples = $#samples;
    }
    @samples = ();
    $sample_start = $local_sec;
  }
}

my(%last_counters,$running_avg);
sub send_time_to_ntp {
  my($shmid,@samples) = @_;

  my(@valid);
  for(my $i = 0; $i < @samples; $i++) {
    if(abs($running_avg-$samples[$i]{offset}) < 0.000010) { # sample is within 10us
      push(@valid, $samples[$i]);
    }
  }
  if(not @valid) {
    print STDERR "reset running avg at ".time()."\n";
    @valid = sort { $a->{offset} <=> $b->{offset} } @samples;
    $running_avg = $valid[int(@valid/2)];
    return send_time_to_ntp($shmid,@samples); # there's now at least 1 sample within 10us of running_avg
  }

  @valid = sort { $a->{offset} <=> $b->{offset} } @valid;
  my $message = $valid[int(@valid/2)];
  my $valid_pct = @valid/@samples*100;
  $running_avg = $running_avg * .5 + $message->{offset} * .5; # weighted average

  my $len = length($message->{message});
  die "wrong message length" unless($len == 96);
  my $ret = shmwrite($shmid, $message->{message}, 0, $len) || die("$!");

  if($last_counters{over_2s} != $counters{over_2s} or $last_counters{over_1s} != $counters{over_1s} or $last_counters{under_1s} != $counters{under_1s} or $last_counters{gps_off} != $counters{gps_off}) {
    printf("Sent offset %+0.6f +2s=%d(%d/%d) +1s=%d(%d/%d) -1s=%d(%d/%d) GPS(%d/%d) %s\n", $message->{offset},
        $counters{over_2s}, $counters{over_2s_min}, $counters{over_2s_max},
        $counters{over_1s}, $counters{over_1s_min}, $counters{over_1s_max},
        $counters{under_1s}, $counters{under_1s_min}, $counters{under_1s_max},
        $counters{gps_off}, $counters{gps_ok},
        $fixtypes[$gps_info{fixtype}]
        );
    %last_counters = %counters;
  }
  %counters = ();
  
  return $valid_pct." ".$running_avg." ".$message->{offset};
}

my $shmid = shmget(NTP_SHMID, 96, S_IRUSR | S_IWUSR);
die "shmget: $!" if ( $shmid < 0 );

open(LOGFILE, ">>gps.log") or die("unable to open gps.log: $!");
LOGFILE->autoflush(1);

open(PPSSAMPLES, ">>pps.log") or die("unable to open pps.log: $!");
PPSSAMPLES->autoflush(1);

# line format:
# P 1305295299 1305299665 10500794 23
# ^ time_pps   time_now   frequenc usb_transfer
# ^mark
# G fixtype,fixsatcount,satcount,avgsnr,day,month,year,hour,minute,second,valid,timestamp
my($now, @last, $line);
my $last_p = 1;
while(my($char,$now_s,$now_us,$ioctl_status) = timeread(fileno(STDIN))) {
  $now = [$now_s,$now_us];
  my $last_i;
  if($char eq "G") {
    $last_i = 0;
  } elsif($char eq "P") {
    $last_i = $last_p % 2 + 1;
    $last_p = $last_i;
    if($ioctl_status != 0) {
      my $lastmsg = tv_interval($last[0],$now);
      printf("[%0.6f] ioctl : %s]\n",$lastmsg,$ioctl_status);
    }
  }
  my $interval = tv_interval($last[$last_i],$now);
  $last[$last_i] = $now;

  $line = $char;
  while($char ne "\n") {
    sysread(STDIN, $char, 1);
    $line .= $char;
  }
  if($line =~ /^P/ and $ioctl_status < 0) { # throw it away
  } else {
    parseline($shmid, $line, $now, $interval);
  }
}

__END__
__C__
#include <sched.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/ioctl.h>

#define P_MSG_TIME 0x5461

int set_rr(int priority) {
  struct sched_param param;

  param.sched_priority = priority;
  return sched_setscheduler(0, SCHED_RR, &param);  
}

void timeread(int fd) {
  char data;
  int status;
  struct timeval now;
  struct timespec pps;
  Inline_Stack_Vars;

  if(read(fd, &data, 1) != 1) {
    Inline_Stack_Reset;
    Inline_Stack_Done;
    return;
  }
  if(data == 'P') {
    status = ioctl(fd, P_MSG_TIME, &pps);
    if(status < 0) {
      status = -errno;
      gettimeofday(&now,NULL);
    } else {
      now.tv_sec = pps.tv_sec;
      now.tv_usec = pps.tv_nsec/1000;
    }
  } else {
    gettimeofday(&now,NULL);
  }

  Inline_Stack_Reset;
  Inline_Stack_Push(sv_2mortal(newSVpvn(&data, 1)));
  Inline_Stack_Push(sv_2mortal(newSViv(now.tv_sec)));
  Inline_Stack_Push(sv_2mortal(newSViv(now.tv_usec)));
  Inline_Stack_Push(sv_2mortal(newSViv(status)));
  Inline_Stack_Done;
}
